<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Фильтрация через функцию</title>
</head>
<body>
	
</body>

<script>

	// Основная функция
	function filter(arr, func) {

		// Создаём массив, в который поместим отфильтрованные элементы
		var newArr = [];

		// этим циклом мы будем наполнять массив
		for(var i = 0; i < arr.length; i++) {

			// В чём же механика этого условия? func - это второй аргумент, который нужен для функции-фильтра. Что это за скобки в нём? Эти скобки нужны для вызова функции, которая вложена в функцию-фильтр. А что это за arr[i]? А это тот параметр, который мы передаём функции, которая вложена в функцию-фильтр. То есть именно этот элемент массива пройдётся по функции-фильру, и если пройдя её функция-фильтр вернёт правду, то наше условие пойдёт дальше, а если это значение элемента изначального массива пройдясь по функции-фильтру в результате обеспечит нам ложь, возвращённую функцией-фильтром, то наше условие не сработает и начнётся следующая итерация цикла.
			if(func(arr[i])) {
				// Добавляем в конец массива значение изначального массива, поскольку оно соответствет условию.
				newArr.push(arr[i])
			}
		}

		// Возвращаем массив. То есть именно он отобразиться пользователю
		return newArr

	}

	// Одна из функци-фильтров: фильтр по промежутку
	// В неё мы передаём два параметра
	function inBetween(a, b) {
		// Вот вся эта функция поднимется в условие в основной функции и там сработает. Но сработает уже и с "a" и "b" (параметрами функции-фильттра) и со значанием, которое мы передаём этой вложенной функции - в нашем случае это очердной элемент исходного массива.
		return function (value) {
			// Вот тут уже всё просто и знакомо нам.
			if (value >= a && value <= b) {
				// Вот именно это значение и вернётся. А куда оно возвратится? Именно это значение нырнёт в тело условия. return как билет для элемента массива в тело условия.
				return value
			}
		}
	}

	// Одна из функци-фильтров: фильтр по соответствию элементам массива

	function inArray(arr) {
		return function(value) {
			// А тут у нас даже цикл. Конструкции с такой сложностью, где есть даже циклы,, я ещё не делал.
			for(var i = 0; i < arr.length; i++) {
				if (arr[i] == value) {
					return value
				}
			}
		}
	}

	// Массив и вызовы функций
	var arr = [1, 2, 3, 4, 5, 6, 7];
	console.log(filter(arr, function(a) {
		return a % 2 == 0
	}));
	console.log( filter(arr, inBetween(3, 6)) );
	console.log( filter(arr, inArray([1, 2, 10])) );
	
</script>

</html>
<!--
В чём же удобство использования вложенной функции? В том, что можно использовать дополнительные аргументы?
-->