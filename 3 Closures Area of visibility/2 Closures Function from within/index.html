<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Задачи</title>
</head>
<body>
	
</body>

<script>
	/*
	Задача 1
	Что будет, если вызов say('Вася'); стоит в самом-самом начале, в первой строке кода?
	*/
/*
	say('Вася'); // Что выведет? Не будет ли ошибки?

	var phrase = 'Привет';

	function say(name) {
		alert( name + ", " + phrase );
	}*/
	/*Первый ответ. На момент начала осуществления кода у интерпетатора будет функция, а вот у переменной будет значение undefined. Но с другой стороны функция способна искать переменные и в глобальном окружении. То есть, с одной стороны, мы видим, что вызывается функция до того, как одна из переменных, котороая в ней используется, инициализирована, а с другой стороны - есть особенность работы фунций находить перменные во вне, то есть в лексическом окружении, в глобальном объекте, в замыкании. Я склоняюсь к тому, что функция сработает, и сработает так, как это было задумано, то есть: "Привет, Вася."
	Ответ. Мы знаем, что значение переменной из внешней области берётся всегда текущее. Текущее значение - undefined. Ответ: "Вася, undefined"
	ВЕРНО*/

/////////////////////////////////////////////////////////////

	/*Задача 2
	Каков будет результат выполнения этого кода?
	Изменится ли внешняя переменная value ?

	P.S. Какими будут ответы, если из строки var value = false убрать var?*/

/*	var value = 0;

	function f() {
	  if (1) {
	    value = true;
	  } else {
	    var value = false;
	  }

	  alert( value );
	}

	f();*/

	/*Первый ответ. Единица в условии означает истину. Как я понял, то к иначе интерпертатор никогда не дойдёт, а переменная получит новое значение true. То есть в результате вызова функции в диалоговом окне будет высвечено true. А если убрать директиву var, то, насколько я понимаю, ничего не поменяется и результат будет тот же. Ответ: true в обоих случаях
	ВЕРНО*/

/////////////////////////////////////////////////////////////

	/*Задача 3
	Каков будет результат выполнения этого кода? Почему?

*/
	function test() {

	  alert( window );

	  var window = 5;

	  alert( window );
	}

	test();

	/*Первый ответ. Второй alert не сработает - это однозначно. к нему даже не дойдёт код, поскольку window - это зарезервированное имя, его нельзя использовать в качестве названий перменных, интерпертатор споткнётся уже на этом месте. А что он отобразит (если отобразит вообще) при вызове window? Тогда нужно определиться с тем, что такое window? window - это объект (объект чего?), частный случай лексического окружения функции. Я склоняюсь к тому, что в выводе мы не увидим свояства, перменные этого объекта, будет отображены акие-то каракули, как и при вызове функции без скобок.
	НЕВЕРНО. Это самый неожиданный ответ. Во-первых, window - это переменная, а объект в котором складируются разные данные, то есть это слово даже не является зарезервированным. Во-второых, первый вызов даст undefined, но это уже закономерно, а второй - 5*/

/////////////////////////////////////////////////////////////

	/*Задача 4
Каков будет результат выполнения кода? Почему?
P.S. Подумайте хорошо! Здесь все ошибаются! P.P.S. Внимание, здесь подводный камень! Ок, вы предупреждены.


	*/
/*	var a = 5

	(function() {
	  alert(a)
	})()*/
	/*Нет точки с запятой после значения переменной*/

/////////////////////////////////////////////////////////////


	/*Задача 5
Если во внутренней функции есть своя переменная с именем currentCount – можно ли в ней получить currentCount из внешней функции?
	*/
/*
	function makeCounter() {
	  var currentCount = 1;

	  return function() {
	    var currentCount;
	    // можно ли здесь вывести currentCount из внешней функции (равный 1)?
	  };
	}

	console.log(makeCounter())
*/
	/*
	Первый ответ. Насколько я понял, то суть задачи сводится к вопросу: если во вложенной функции переменная объявлена, но не инициализсрована, а в объемлющей переменной эта переменная и инициализирована, и ей присвоено значение? Кстати, что значит вернуть функцию в целом, то есть не какое-то значанеи внутри неё? И как будет вести себя эта вложенная функция в связи с замыканием: сможет ли она искать переменные во вне или нет? Я предполагаю, что именно в нашем случае у переменной будет значение undefined, поскольку вложенная функция выполняться не будет, она будет возвращатся. То есть дело не дойдёт до выхода на глобальное окружение. Нет, оно скорее всего дойдёт, но уже в другом лексическом окружении, где будет вызвана функция.
	Ответ. return перед вложенной функцией - это верно. А вот отсутствие return перед переменной внутри вложенной функции - это интерестно. Возвращаясь к основному вопросу, думаю, что да, если во внутренней функции есть своя переменная с именем аналогичным во внешней функции, то во внутренней можно получить эту переменную из внешней. Ответ: возвратится 1.
	НЕВЕРНО
	Выведет вложенную функцию с её телом. Более того ответ - нельзя, нельзя получить значение внешней переменной, если есть внутренняя.*/

/////////////////////////////////////////////////////////////

	/*Задача 6
Что выведут эти вызовы, если переменная currentCount находится вне makeCounter?

	*/
/*	var currentCount = 1;

	function makeCounter() {
	  return function() {
	    return currentCount++;
	  };
	}

	var counter = makeCounter();
	var counter2 = makeCounter();

	alert( counter() ); // ?
	alert( counter() ); // ?

	alert( counter2() ); // ?
	alert( counter2() ); // ?
	*/

	/*Первый ответ. Первая мысль - значание при каждом вызове будет на единицу большим, чем предыдущее значание. То есть не смотря на то, что у нас два разных счётчика свою переменную они будут работать, если так можно сказать, как один. Всё же вложенная функци будет последовательно вызываться в том замыкании, где присутствкует наша переменная. Воу! Я не понял а почему у переменных стят скобки, словно это функции?
	Ответ: 2, 3, 4, 5
	ПОЧТИ ВЕРНО. Действительно, в силу того, что в этом коде счётчиков функции будут брать значение переменной из самого объемлющего (не знаю как правильно сказать) лексического окружения, числа последовательно увеличиваются на единицу. ОДнако начиная не с двойки, а с единицы. ТО есть ответ: 1, 2, 3, 4*/
	
</script>

</html>